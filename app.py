# -*- coding: utf-8 -*-
"""Predictive Analysis (Real Estate Lease optimization).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sMsT_3u5lpVWcmUkSQ9YvzuYwRJ4RG6i
"""

#!pip install ipywidgets

# Google drive
#from google.colab import drive
#drive.mount('/content/drive')

#pip install streamlit streamlit-folium

import streamlit as st
import pandas as pd
import folium
from folium.plugins import MarkerCluster
import streamlit.components.v1 as components
import requests
#from ipywidgets import interact, widgets, Dropdown, IntSlider, VBox
#from IPython.display import display

# Load and clean dataset
costar_df = pd.read_csv("Costar_GEO_CLEANED_CA.csv")
costar_df["Zip"] = costar_df["Zip"].astype(str).str.strip().str[:5]
costar_df["City"] = costar_df["City"].astype(str).str.title().str.strip()

# Create mapping: city -> list of ZIPs
city_zip_dict = costar_df.groupby("City")["Zip"].unique().apply(list).to_dict()

# UI widgets
selected_city = st.selectbox("Select a city",sorted(city_zip_dict.keys()))
selected_zip= st.selectbox("Select the Zip",sorted(city_zip_dict[selected_city]))
min_size_slider = st.slider(
    "Min Size (SF)",
    min_value=50000,
    max_value=1500000,
    value=50000,
    step=10000
)

min_parking_slider = st.slider(
    "Min Parking",
    min_value=0,
    max_value=1000,
    value=50,
    step=50
)

# Update ZIPs based on city
#def update_zip_options(change):
 #   selected_city = change["new"]
  #  zip_dropdown.options = city_zip_dict.get(selected_city, [])

#st.write(f"Filters applied:\nCity: {city_selected}, ZIP: {zip_selected}, Min Size: {min_size}, Min Parking: {min_parking}")

#city_dropdown.observe(update_zip_options, names='value')
#update_zip_options({'new': city_dropdown.value})  # initialize
# Dashboard logic
#def filter_and_display(selected_city, selected_zip, min_size, min_parking):
df = costar_df
[
    (costar_df["City"] == selected_city) &
    (costar_df["Zip"] == selected_zip) &
    (costar_df["Total Available Space (SF)"] >= min_size) &
    (costar_df["Number Of Parking Spaces"] >= min_parking)
]
m = folium.Map(location=[36.7783, -119.4179], zoom_start=7, tiles="OpenStreetMap")
ca_url = "https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json"
ca_geo = requests.get(ca_url).json()
ca_shape = [f for f in ca_geo["features"] if f["properties"]["name"] == "California"]
folium.GeoJson(
    {"type": "FeatureCollection", "features": ca_shape},
    style_function=lambda x: {
        "fillColor": "#ffffff00",
        "color": "black",
        "weight": 1.5,
        "fillOpacity": 0.1,
    }
).add_to(m)
cluster = MarkerCluster().add_to(m)
for _, row in df.iterrows():
    popup = folium.Popup(
        f"<b>{row.get('Property Name', 'Unnamed')}</b><br>"
        f"Address: {row.get('Property Address', '')}<br>"
        f"Rent: ${row['Rent']}<br>"
        f"Size: {row['Total Available Space (SF)']} SF<br>"
        f"Parking: {row['Number Of Parking Spaces']}",
        max_width=300
    )
folium.Marker(
    location=[row["Latitude"], row["Longitude"]],
    popup=popup,
    icon=folium.Icon(color='darkblue', icon='industry', prefix='fa', icon_color='yellow')
).add_to(cluster)
if not df.empty:
    legend_html = f"""
        <div style="
            position: fixed; top: 60px; left: 50px; width: 260px;
            z-index:9999; background-color: white;
            border: 2px solid black; padding: 10px; font-size: 14px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);">
            <b>Predictive Analysis</b><br>
            ZIP: <b>{selected_zip}</b><br>
            Avg. Rent: ${round(df["Rent"].mean(), 2)} / SF<br>
            Avg. Size: {int(df["Total Available Space (SF)"].mean())} SF<br>
            Sites Found: {len(df)}
        </div>
        """
    m.get_root().html.add_child(folium.Element(legend_html))
map_html = m._repr_html_()
components.html(map_html, height=600, scrolling=False)

# Arrange widgets vertically

#display(dashboard_widgets)

# Bind interactive function
#interact(
#    filter_and_display(
#    selected_city=city_dropdown,
#    selected_zip=zip_dropdown,
#    min_size=min_size_slider,
#    min_parking=min_parking_slider
#)
